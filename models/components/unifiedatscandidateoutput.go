// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"errors"
	"fmt"
	"github.com/panoratech/go-sdk/internal/utils"
	"time"
)

type UnifiedAtsCandidateOutputAttachmentsType string

const (
	UnifiedAtsCandidateOutputAttachmentsTypeStr                        UnifiedAtsCandidateOutputAttachmentsType = "str"
	UnifiedAtsCandidateOutputAttachmentsTypeUnifiedAtsAttachmentOutput UnifiedAtsCandidateOutputAttachmentsType = "UnifiedAtsAttachmentOutput"
)

type UnifiedAtsCandidateOutputAttachments struct {
	Str                        *string
	UnifiedAtsAttachmentOutput *UnifiedAtsAttachmentOutput

	Type UnifiedAtsCandidateOutputAttachmentsType
}

func CreateUnifiedAtsCandidateOutputAttachmentsStr(str string) UnifiedAtsCandidateOutputAttachments {
	typ := UnifiedAtsCandidateOutputAttachmentsTypeStr

	return UnifiedAtsCandidateOutputAttachments{
		Str:  &str,
		Type: typ,
	}
}

func CreateUnifiedAtsCandidateOutputAttachmentsUnifiedAtsAttachmentOutput(unifiedAtsAttachmentOutput UnifiedAtsAttachmentOutput) UnifiedAtsCandidateOutputAttachments {
	typ := UnifiedAtsCandidateOutputAttachmentsTypeUnifiedAtsAttachmentOutput

	return UnifiedAtsCandidateOutputAttachments{
		UnifiedAtsAttachmentOutput: &unifiedAtsAttachmentOutput,
		Type:                       typ,
	}
}

func (u *UnifiedAtsCandidateOutputAttachments) UnmarshalJSON(data []byte) error {

	var unifiedAtsAttachmentOutput UnifiedAtsAttachmentOutput = UnifiedAtsAttachmentOutput{}
	if err := utils.UnmarshalJSON(data, &unifiedAtsAttachmentOutput, "", true, true); err == nil {
		u.UnifiedAtsAttachmentOutput = &unifiedAtsAttachmentOutput
		u.Type = UnifiedAtsCandidateOutputAttachmentsTypeUnifiedAtsAttachmentOutput
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = UnifiedAtsCandidateOutputAttachmentsTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for UnifiedAtsCandidateOutputAttachments", string(data))
}

func (u UnifiedAtsCandidateOutputAttachments) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.UnifiedAtsAttachmentOutput != nil {
		return utils.MarshalJSON(u.UnifiedAtsAttachmentOutput, "", true)
	}

	return nil, errors.New("could not marshal union type UnifiedAtsCandidateOutputAttachments: all fields are null")
}

type ApplicationsType string

const (
	ApplicationsTypeStr                         ApplicationsType = "str"
	ApplicationsTypeUnifiedAtsApplicationOutput ApplicationsType = "UnifiedAtsApplicationOutput"
)

type Applications struct {
	Str                         *string
	UnifiedAtsApplicationOutput *UnifiedAtsApplicationOutput

	Type ApplicationsType
}

func CreateApplicationsStr(str string) Applications {
	typ := ApplicationsTypeStr

	return Applications{
		Str:  &str,
		Type: typ,
	}
}

func CreateApplicationsUnifiedAtsApplicationOutput(unifiedAtsApplicationOutput UnifiedAtsApplicationOutput) Applications {
	typ := ApplicationsTypeUnifiedAtsApplicationOutput

	return Applications{
		UnifiedAtsApplicationOutput: &unifiedAtsApplicationOutput,
		Type:                        typ,
	}
}

func (u *Applications) UnmarshalJSON(data []byte) error {

	var unifiedAtsApplicationOutput UnifiedAtsApplicationOutput = UnifiedAtsApplicationOutput{}
	if err := utils.UnmarshalJSON(data, &unifiedAtsApplicationOutput, "", true, true); err == nil {
		u.UnifiedAtsApplicationOutput = &unifiedAtsApplicationOutput
		u.Type = ApplicationsTypeUnifiedAtsApplicationOutput
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = ApplicationsTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Applications", string(data))
}

func (u Applications) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.UnifiedAtsApplicationOutput != nil {
		return utils.MarshalJSON(u.UnifiedAtsApplicationOutput, "", true)
	}

	return nil, errors.New("could not marshal union type Applications: all fields are null")
}

type UnifiedAtsCandidateOutputTagsType string

const (
	UnifiedAtsCandidateOutputTagsTypeStr                 UnifiedAtsCandidateOutputTagsType = "str"
	UnifiedAtsCandidateOutputTagsTypeUnifiedAtsTagOutput UnifiedAtsCandidateOutputTagsType = "UnifiedAtsTagOutput"
)

type UnifiedAtsCandidateOutputTags struct {
	Str                 *string
	UnifiedAtsTagOutput *UnifiedAtsTagOutput

	Type UnifiedAtsCandidateOutputTagsType
}

func CreateUnifiedAtsCandidateOutputTagsStr(str string) UnifiedAtsCandidateOutputTags {
	typ := UnifiedAtsCandidateOutputTagsTypeStr

	return UnifiedAtsCandidateOutputTags{
		Str:  &str,
		Type: typ,
	}
}

func CreateUnifiedAtsCandidateOutputTagsUnifiedAtsTagOutput(unifiedAtsTagOutput UnifiedAtsTagOutput) UnifiedAtsCandidateOutputTags {
	typ := UnifiedAtsCandidateOutputTagsTypeUnifiedAtsTagOutput

	return UnifiedAtsCandidateOutputTags{
		UnifiedAtsTagOutput: &unifiedAtsTagOutput,
		Type:                typ,
	}
}

func (u *UnifiedAtsCandidateOutputTags) UnmarshalJSON(data []byte) error {

	var unifiedAtsTagOutput UnifiedAtsTagOutput = UnifiedAtsTagOutput{}
	if err := utils.UnmarshalJSON(data, &unifiedAtsTagOutput, "", true, true); err == nil {
		u.UnifiedAtsTagOutput = &unifiedAtsTagOutput
		u.Type = UnifiedAtsCandidateOutputTagsTypeUnifiedAtsTagOutput
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = UnifiedAtsCandidateOutputTagsTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for UnifiedAtsCandidateOutputTags", string(data))
}

func (u UnifiedAtsCandidateOutputTags) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.UnifiedAtsTagOutput != nil {
		return utils.MarshalJSON(u.UnifiedAtsTagOutput, "", true)
	}

	return nil, errors.New("could not marshal union type UnifiedAtsCandidateOutputTags: all fields are null")
}

type UnifiedAtsCandidateOutput struct {
	// The first name of the candidate
	FirstName *string `json:"first_name,omitempty"`
	// The last name of the candidate
	LastName *string `json:"last_name,omitempty"`
	// The company of the candidate
	Company *string `json:"company,omitempty"`
	// The title of the candidate
	Title *string `json:"title,omitempty"`
	// The locations of the candidate
	Locations *string `json:"locations,omitempty"`
	// Whether the candidate is private
	IsPrivate *bool `json:"is_private,omitempty"`
	// Whether the candidate is reachable by email
	EmailReachable *bool `json:"email_reachable,omitempty"`
	// The remote creation date of the candidate
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// The remote modification date of the candidate
	RemoteModifiedAt *time.Time `json:"remote_modified_at,omitempty"`
	// The last interaction date with the candidate
	LastInteractionAt *time.Time `json:"last_interaction_at,omitempty"`
	// The attachments UUIDs of the candidate
	Attachments []UnifiedAtsCandidateOutputAttachments `json:"attachments,omitempty"`
	// The applications UUIDs of the candidate
	Applications []Applications `json:"applications,omitempty"`
	// The tags of the candidate
	Tags []UnifiedAtsCandidateOutputTags `json:"tags,omitempty"`
	// The urls of the candidate, possible values for Url type are WEBSITE, BLOG, LINKEDIN, GITHUB, or OTHER
	Urls []URL `json:"urls,omitempty"`
	// The phone numbers of the candidate
	PhoneNumbers []Phone `json:"phone_numbers,omitempty"`
	// The email addresses of the candidate
	EmailAddresses []Email `json:"email_addresses,omitempty"`
	// The custom field mappings of the object between the remote 3rd party & Panora
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	// The UUID of the candidate
	ID *string `json:"id,omitempty"`
	// The id of the candidate in the context of the 3rd Party
	RemoteID *string `json:"remote_id,omitempty"`
	// The remote data of the candidate in the context of the 3rd Party
	RemoteData map[string]any `json:"remote_data,omitempty"`
	// The created date of the object
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The modified date of the object
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
}

func (u UnifiedAtsCandidateOutput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UnifiedAtsCandidateOutput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *UnifiedAtsCandidateOutput) GetFirstName() *string {
	if o == nil {
		return nil
	}
	return o.FirstName
}

func (o *UnifiedAtsCandidateOutput) GetLastName() *string {
	if o == nil {
		return nil
	}
	return o.LastName
}

func (o *UnifiedAtsCandidateOutput) GetCompany() *string {
	if o == nil {
		return nil
	}
	return o.Company
}

func (o *UnifiedAtsCandidateOutput) GetTitle() *string {
	if o == nil {
		return nil
	}
	return o.Title
}

func (o *UnifiedAtsCandidateOutput) GetLocations() *string {
	if o == nil {
		return nil
	}
	return o.Locations
}

func (o *UnifiedAtsCandidateOutput) GetIsPrivate() *bool {
	if o == nil {
		return nil
	}
	return o.IsPrivate
}

func (o *UnifiedAtsCandidateOutput) GetEmailReachable() *bool {
	if o == nil {
		return nil
	}
	return o.EmailReachable
}

func (o *UnifiedAtsCandidateOutput) GetRemoteCreatedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.RemoteCreatedAt
}

func (o *UnifiedAtsCandidateOutput) GetRemoteModifiedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.RemoteModifiedAt
}

func (o *UnifiedAtsCandidateOutput) GetLastInteractionAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.LastInteractionAt
}

func (o *UnifiedAtsCandidateOutput) GetAttachments() []UnifiedAtsCandidateOutputAttachments {
	if o == nil {
		return nil
	}
	return o.Attachments
}

func (o *UnifiedAtsCandidateOutput) GetApplications() []Applications {
	if o == nil {
		return nil
	}
	return o.Applications
}

func (o *UnifiedAtsCandidateOutput) GetTags() []UnifiedAtsCandidateOutputTags {
	if o == nil {
		return nil
	}
	return o.Tags
}

func (o *UnifiedAtsCandidateOutput) GetUrls() []URL {
	if o == nil {
		return nil
	}
	return o.Urls
}

func (o *UnifiedAtsCandidateOutput) GetPhoneNumbers() []Phone {
	if o == nil {
		return nil
	}
	return o.PhoneNumbers
}

func (o *UnifiedAtsCandidateOutput) GetEmailAddresses() []Email {
	if o == nil {
		return nil
	}
	return o.EmailAddresses
}

func (o *UnifiedAtsCandidateOutput) GetFieldMappings() map[string]any {
	if o == nil {
		return nil
	}
	return o.FieldMappings
}

func (o *UnifiedAtsCandidateOutput) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *UnifiedAtsCandidateOutput) GetRemoteID() *string {
	if o == nil {
		return nil
	}
	return o.RemoteID
}

func (o *UnifiedAtsCandidateOutput) GetRemoteData() map[string]any {
	if o == nil {
		return nil
	}
	return o.RemoteData
}

func (o *UnifiedAtsCandidateOutput) GetCreatedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *UnifiedAtsCandidateOutput) GetModifiedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.ModifiedAt
}
